

下面进入正题，如果你还没有对yield有个初步分认识，那么你先把yield看做“return”，
这个是直观的，它首先是个return，普通的return是什么意思，就是在程序中返回某个值，
返回之后程序就不再往下运行了。
看做return之后再把它看做一个是生成器（generator）的一部分
（带yield的函数才是真正的迭代器），
好了，如果你对这些不明白的话，那先把yield看做return,然后直接看下面的程序，
你就会明白yield的全部意思了(只是先当做return，本质向后看就会明白)。

# ==----------------------------------------------------------------=====
不会将所有数据取出来存入内存中；而是返回了一个对象；
可以通过对象获取数据；用多少取多少，可以节省内容空间。
除了能返回一个值，还不会终止循环的运行；
每次执行到yield，因为底层的实现就是中断的原理，保存栈帧，加载栈帧。
每次执行结束内存释放，执行的时候占用一点内存，消耗的内存资源就很少
#============================================================================
通常yield都是放在一个函数中，该函数就变成了生成器函数，该函数就变成了一个迭代器
生成器函数一般都是通过for循环调用，for循环自带next方法
分布式爬虫会经常使用yield,yield直接放在for循环的内部
爬虫代码运行时候，for循环自动调用next方法，yield就会不断执行，直到爬取结束
使用yield也会大大减少爬虫运行时候的内存消耗
#-------------------------------------------------------------------

# 包含yield关键字，就变成了生成器函数
# 调用函数并不会执行语句
def foo():
    print('Starting.....')
    while True:
        res = yield 4
        print("res:", res)

# 下面调用函数并没有执行，可以先将后面的语句注释掉
# 逐行运行代码观察效果
g = foo()
print("第一次调用执行结果：")
print(next(g))
print("*" * 100)

print("第二次调用执行结果：")
print(next(g))
print("*" * 100）

