
python中数据通常为赋值， 深拷贝，浅拷贝等多种结果值。
拷贝就是拷贝，何来深浅之说？
Python中，对象的赋值，拷贝（深/浅拷贝）之间是有差异的，如果使用的时候不注意，就可能产生意外的结果
其实这个是由于共享内存导致的结果
拷贝：原则上就是把数据分离出来，复制其数据，并以后修改互不影响。
先看 一个非拷贝的例子
=赋值：数据完全共享（=赋值是在内存中指向同一个对象，如果是可变(mutable)类型，比如列表，修改其中一个，另一个必定改变
如果是不可变类型(immutable),比如字符串，修改了其中一个，另一个并不会变

#------------------------------------------------------------------------------------------------------------
#--------------------------------------------------------------------------------------------------------------------------

l1 = [1, 2, 3, ['aa', 'bb']]
l2 = l1
l2[0]='aaa'
l2[3][0]='bbb'
print(l1)  #['aaa', 2, 3, ['bbb', 'bb']]
print(id(l1)==id(l2))  #True

# l2 = l1 ，l1 完全赋值给l2 ，l2的内存地址与l1 相同，即内存完全指向

# # 浅拷贝
# 如上述代码，l2浅拷贝了l1 ，之后l2把其列表中的列表的元素给修改，从结果看出，l1也被修改了。
# 但是仅仅修改l1列表中的第一层元素，却并没有影响l2。

# 比较一下l2与l1的内存地址：False，说明，l2在内存中已经独立出一部分复制了l1的数据，但是只是浅拷贝，
# 第二层的数据并没有拷贝成功，而是指向了l1中的第二层数据的内存地址，所以共享内存‘相当于‘’等号赋值’‘，
# 所以就会有l2中第二层数据发生变化，l1中第二层数据也发生变化

# --------------------------------------------------------------------------------------------------------------------
深拷贝

import copy
l1 = [1, 2, 3, [11, 22, 33]]
# l2 = copy.copy(l1)  浅拷贝
l2 = copy.deepcopy(l1)
print(l1,'>>>',l2)
l2[3][0] = 1111
print(l1,">>>",l2)




